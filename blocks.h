#ifndef _BPJ_PUZZLE_BLOCKS_H
#define _BPJ_PUZZLE_BLOCKS_H

#include <string>

/*
 * Cell type
 * The basic type used in every grid class
 * By convention, a numeric zero is an empty cell
 */
typedef unsigned char Cell;

/*
 * Grid class
 * This class and its descendents store 2D arrangements of cells.
 * In general, a Grid is mutable, but its dimensions are not.
 */
class Grid {
private:
  Cell* cells;
  int nr, nc;//Dimensions of grid
  
public:
  Grid(int nr = 1, int nc = 1);
  Grid(const Grid& grid);
  virtual ~Grid();

  Grid& operator=(const Grid& grid);

  inline int rows() const {return nr;}
  inline int cols() const {return nc;}
  inline Cell at(int r, int c) const {return cells[r * nc + c];}
  inline void set(int r, int c, Cell cell) {cells[r * nc + c] = cell;}
};

/*
 * Block class
 * Represents an "ideal" block, i.e. a class of shapes but not an instance
 * Adds a pivot point for rotation to the grid class.
 * Also adds collision and bounding routines.
 */
class Block : public Grid {
protected:
  int pr, pc;//Pivot row and column

public:
  Block(int nr = 1, int nc = 1);
  Block(const Grid& grid);
  
  const Block& map(const std::string& cells, const std::string& map, int r, int c);

  inline void setPivot(int r, int c) {pr = r; pc = c;}
  inline void getPivot(int& r, int& c) const {r = pr; c = pc;}
  Block leftRotate() const;
  Block rightRotate() const;

  bool inBounds(const Grid& grid, int r, int c) const;
  bool collides(const Grid& grid, int r, int c) const;
};

/*
 * FallingBlock class
 * Represents an instance of a falling block, usually generated by a Block object
 * An object of this type has a number of "ticks" before its pivot point drops.
 * A game loop can call tick a certain number of times per frame and adjust accordingly.
 */
class FallingBlock : public Block {
protected:
  int ticks, currentTicks, r, c;//Position of pivot with respect to grid
  
public:
  FallingBlock();
  FallingBlock(const Block& block, int ticks = 1);
  
  inline void setTicks(int ticks) {this->ticks = ticks; currentTicks = 0;}
  inline int getTicks() const {return ticks;}
  inline int getCurrentTicks() const {return currentTicks;}

  inline void setPosition(int r, int c) {this->r = r; this->c = c;}
  inline void getPosition(int& r, int& c) const {r = this->r; c = this->c;}
  void getDisplayPosition(const Grid& grid, float& r, float& c) const;
  
  inline bool willFall() const {return currentTicks == ticks - 1;}
  void tick();

  bool landed(const Grid& grid) const;
  void plant(Grid& grid) const;
};

#endif
